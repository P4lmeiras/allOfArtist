//@ts-check

// NAME: All Of Artist
// AUTHOR: P4lmeiras
// DESCRIPTION: Create a playlist with all songs of an artist

/// <reference path="../../spicetify-cli/globals.d.ts" />
(function allOfArtist(){ 
    const{
        CosmosAsync,
        URI
    } = Spicetify;
    if (!(CosmosAsync && URI)){
        setTimeout(allOfArtist, 10);
        return;
    }

    const buttontxt = "Create All Of ..."
    
    /*function btnText(uris){ 
        buttontxt = "Create All Of " + artistName.name
    }*/
    

    async function getArtist(uri){
	var artistData = {}
	try{
	    let artist = await CosmosAsync.get('https://api.spotify.com/v1/artists/'+uri)
	    artistData.id = artist.id
	    artistData.name = artist.name
	}
	catch{
	    try{
		let artist = await CosmosAsync.get('https://api.spotify.com/v1/tracks/'+uri)
		artistData.id = artist.artists[0].id
		artistData.name = artist.artists[0].name
	    }
	    catch{
		artistData.id = artistData.name = 'ERROR'
	    }
	}
	/*if (artist.error.status == '404'){
	    artist = await CosmosAsync.get('https://api.spotify.com/v1/tracks/'+uri)
	    artistName = artist.artists[0].name
	}
	else*/
	    //artistName = artist.error.message
	//artistData.name = artistData.name.replace(/\s/g, '%20');
	return artistData;
	//return 'teste';
    }

    async function makePlaylist(uris){
        const rawUri = uris[0]
        const uri = rawUri.split(":")[2]
		const artist = await getArtist(uri)
        var offset = 0
        if(artist.id != 'ERROR'){
	    	const artistTracksSearchRaw = await CosmosAsync.get('https://api.spotify.com/v1/search?query=artist%3A'+artist.name+'&type=track&offset='+offset+'&limit=50')
	    	var artistTracks = []
	    	var artistTracksSearch = artistTracksSearchRaw.tracks.items
	    	for (let i = 0; i < artistTracksSearch.length; i++){
				var check = false;
				for (let r = 0; r < artistTracksSearch[i].artists.length; r++){
		    		if(artistTracksSearch[i].artists[r].id == artist.id)
						check = true;
				}
				if(check)
		    		artistTracks.push(artistTracksSearch[i].name);
	    	};
			//artistTracksSearch.foreach((track) => {
	    	//let t = track.name
	    	//artistTracks.push(t);
			//});*/
	    	Spicetify.PopupModal.display({
				title: "Content",
				content: artistTracks//uri+' '+artistTracksSearch[0].artists.length//artistName //artistTracks[0]+artistTracks[1]+artistTracks[2],
	    	});
		}
		else{
	    	Spicetify.PopupModal.display({
			title: "Content",
			content: 'Error',
	    	});
		}
    }
 
	async function makeSimplePlaylist(uris){
		const rawUri = uris[0]
        const uri = rawUri.split(":")[2]
        const artist = await getArtist(uri)
		const user = await CosmosAsync.get('https://api.spotify.com/v1/me')
		if(artist.id != 'ERROR'){
			var artistAlbumsRaw = await CosmosAsync.get('https://api.spotify.com/v1/artists/'+artist.id+'/albums?include_groups=album,single,appears_on&limit=50&offset=0')
			const total = artistAlbumsRaw.total
			var artistAlbums = []
			var end = false;
			do{
				for(let i = 0; i < artistAlbumsRaw.items.length; i++){
					if(artistAlbumsRaw.items[i].album_type != 'compilation'){
						let tempDate = artistAlbumsRaw.items[i].release_date.replace(/-/g, '')
						while(tempDate.length < 8){
							tempDate += '0'
						}
						artistAlbums.push([tempDate, artistAlbumsRaw.items[i].id]);
					}
				}
				if(artistAlbumsRaw.next != null)
					artistAlbumsRaw = await CosmosAsync.get(artistAlbumsRaw.next)
				else
					break
			}while(artistAlbums.length < total)
			artistAlbums.sort()
			const newPlaylist = await CosmosAsync.post('https://api.spotify.com/v1/users/' + user.id + '/playlists', {
            	name: 'All Of '+artist.name,
				description: 'Playlist with all '+artist.name+' songs, generated by spicetify\'s extenstion allOfArtist',
				public: false,
				collaborative: false
        	});
			await addFromAlbums(newPlaylist.id,artist,artistAlbums)
			Spicetify.PopupModal.display({
				title: "allOfArtist",
				content: 'All of '+artist.name+' created.'
			})
		}
		else{
			Spicetify.PopupModal.display({
				title: 'allOfArtist',
				content: 'ERROR',
			})
		}
	}
	
	async function addFromAlbums(playlistId,artist,array){
		for(let i = 0; i < array.length; i++){
			var episodes = []
			var removeTracks = []
			var allTracks = []
			var tracks = []
			var albumTracks = await CosmosAsync.get('https://api.spotify.com/v1/albums/'+array[i][1]+'/tracks?offset=0&limit=50')
			for(let r = 0; r < albumTracks.items.length; r++){
				for(let c = 0; c < albumTracks.items[r].artists.length; c++){
					if(albumTracks.items[r].artists[c].id == artist.id){
						if(allTracks.indexOf(albumTracks.items[r].name) > -1){
							var lastMatchIndex = 0
							while(allTracks.indexOf(albumTracks.items[r].name, c) > -1){
								lastMatchIndex = allTracks.indexOf(albumTracks.items[r].name, c)
								if(lastMatchIndex == -1)
									removeTracks.push(albumTracks.items[r].id)
							}
						}
						allTracks.push([albumTracks.items[r].name, albumTracks.items[r].id])
						tracks.push('spotify:'+albumTracks.items[r].type+':'+albumTracks.items[r].id)
						if(albumTracks.items[r].type == 'episode')
							episodes.push(albumTracks.items[r].id)
					}
				}
			}
			await CosmosAsync.post('https://api.spotify.com/v1/playlists/'+playlistId+'/tracks', {
				uris: tracks
			});
		}
		/*for(let i = 0; i < removeTracks.length/100; i++){
			
		}*/
	}

    function shouldDisplayContextMenu(uris){
        if (uris.length > 1){
            return false;
        }
        const uri = uris[0]
        const uriObj = Spicetify.URI.fromString(uri);
        if (uriObj.type === Spicetify.URI.Type.TRACK || uriObj.type === Spicetify.URI.Type.ARTIST){
            return true;
        }
        return false;
    }

    const cntxMenu = new Spicetify.ContextMenu.Item(
        buttontxt,
        //makePlaylist,
        makeSimplePlaylist,
		shouldDisplayContextMenu,
    );

    cntxMenu.register();
})();
