//@ts-check

// NAME: All Of Artist
// AUTHOR: P4lmeiras
// DESCRIPTION: Create a playlist with all songs of an artist

/// <reference path="../../spicetify-cli/globals.d.ts" />
(function allOfArtist(){ 
    const{
        CosmosAsync,
        URI
    } = Spicetify;
    if (!(CosmosAsync && URI)){
        setTimeout(allOfArtist, 10);
        return;
    }

	const buttontxt = 'Create All Of'

    async function getArtist(id){
		var artistData = {}
		try{
	    	let artist = await CosmosAsync.get('https://api.spotify.com/v1/artists/'+id);
	    	artistData.id = artist.id;
	    	artistData.name = artist.name;
		}
		catch{
			try{
				let artist = await CosmosAsync.get('https://api.spotify.com/v1/albums/'+id);
				artistData.id = artist.artists[0].id;
				artistData.name = artist.artists[0].name;
			}
			catch{
	    		try{
					let artist = await CosmosAsync.get('https://api.spotify.com/v1/tracks/'+id);
					artistData.id = artist.artists[0].id;
					artistData.name = artist.artists[0].name;
	    		}
	    		catch{
					artistData.id = artistData.name = 'ERROR';
	    		}
			}
		}
		return artistData;
    }
 
	async function makePlaylist_getTracks(uris){
        const uri = uris[0].split(":")[2];
        artistData = await getArtist(uri);
		const user = await CosmosAsync.get('https://api.spotify.com/v1/me');
		if(artistData.id != 'ERROR'){
			var artistAlbumsRaw = await CosmosAsync.get('https://api.spotify.com/v1/artists/'+artistData.id+'/albums?include_groups=album,single,appears_on&limit=50&offset=0');
			const total = artistAlbumsRaw.total;
			var artistAlbums = [];
			var end = false;
			do{
				for(let i = 0; i < artistAlbumsRaw.items.length; i++){
					if(artistAlbumsRaw.items[i].album_type != 'compilation'){
						let tempDate = artistAlbumsRaw.items[i].release_date.replace(/-/g, '');
						while(tempDate.length < 8){
							tempDate += '0';
						}
						artistAlbums.push([tempDate, artistAlbumsRaw.items[i].id]);
					}
				}
				if(artistAlbumsRaw.next != null)
					artistAlbumsRaw = await CosmosAsync.get(artistAlbumsRaw.next);
				else
					break;
			}while(artistAlbums.length < total)
			artistAlbums.sort();
			const newPlaylist = await CosmosAsync.post('https://api.spotify.com/v1/users/' + user.id + '/playlists', {
            	name: 'All Of '+artistData.name,
				description: 'Playlist with all '+artistData.name+' songs, generated by spicetify\'s extenstion allOfArtist',
				public: false,
				collaborative: false
        	});
			await addFromAlbums(newPlaylist.id,artistData,artistAlbums);
			Spicetify.PopupModal.display({
				title: "allOfArtist",
				content: 'All of '+artistData.name+' created.'
			});
		}
		else{
			Spicetify.PopupModal.display({
				title: 'allOfArtist',
				content: 'ERROR'
			});
		}
	}
	
	async function addFromAlbums(playlistId,artistData,array){
		for(let i = 0; i < array.length; i++){
			var episodes = [];
			var removeTracks = [];
			var allTracks = [];
			var tracks = [];
			var albumTracks = await CosmosAsync.get('https://api.spotify.com/v1/albums/'+array[i][1]+'/tracks?offset=0&limit=50');
			while(true){
				for(let r = 0; r < albumTracks.items.length; r++){
					for(let c = 0; c < albumTracks.items[r].artists.length; c++){
						if(albumTracks.items[r].artists[c].id == artistData.id){
							if(allTracks.indexOf(albumTracks.items[r].name) > -1){
								var lastMatchIndex = 0;
								while(allTracks.indexOf(albumTracks.items[r].name, c) > -1){
									lastMatchIndex = allTracks.indexOf(albumTracks.items[r].name, c);
									if(lastMatchIndex == -1)
										removeTracks.push(albumTracks.items[r].id);
								}
							}
							allTracks.push([albumTracks.items[r].name, albumTracks.items[r].id]);
							tracks.push('spotify:'+albumTracks.items[r].type+':'+albumTracks.items[r].id);
							if(albumTracks.items[r].type == 'episode')
								episodes.push(albumTracks.items[r].id);
						}
					}
				}
				if(albumTracks.next != null)
					albumTracks = await CosmosAsync.get(albumTracks.next);
				else
					break;
			}
			await CosmosAsync.post('https://api.spotify.com/v1/playlists/'+playlistId+'/tracks', {
				uris: tracks
			});
		}
	}

    function shouldDisplayContextMenu(uris){
        if (uris.length > 1){
            return false;
        }
        const uri = uris[0];
        const uriObj = Spicetify.URI.fromString(uri);
        if (uriObj.type === Spicetify.URI.Type.TRACK || uriObj.type === Spicetify.URI.Type.ARTIST || uriObj.type === Spicetify.URI.Type.ALBUM){
			return true;
        }
        return false;
    }

    const cntxMenu = new Spicetify.ContextMenu.Item(
        buttontxt,
        makePlaylist_getTracks,
		shouldDisplayContextMenu,
    );

    cntxMenu.register();
})();
